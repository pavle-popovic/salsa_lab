[
  {
    "module_name": "Core",
    "description": "Application entry point and configuration",
    "files": [
      {
        "path": "main.py",
        "logic": """1. Imports: FastAPI, CORSMiddleware. Routers: auth, users, courses, progress, submissions, admin, payments. Config: settings.
2. Initialize FastAPI app.
3. Setup CORS middleware allowing origins from settings.CORS_ORIGINS.
4. Include all routers with appropriate prefixes (e.g., /auth, /users, /courses).
5. Define global exception handler for generic errors.
6. Root endpoint GET / returning {message: 'Welcome to HedgeFront API'}."""
      },
      {
        "path": "config.py",
        "logic": """1. Imports: BaseSettings from pydantic-settings.
2. Class Settings(BaseSettings):
   - DATABASE_URL: str
   - SECRET_KEY: str
   - ALGORITHM: str = 'HS256'
   - ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
   - STRIPE_SECRET_KEY: str
   - STRIPE_WEBHOOK_SECRET: str
   - AWS_ACCESS_KEY_ID: str
   - AWS_SECRET_ACCESS_KEY: str
   - AWS_BUCKET_NAME: str
   - AWS_REGION: str
   - CORS_ORIGINS: list[str] = ['*']
3. Config inner class to read .env file.
4. Instantiate settings object."""
      },
      {
        "path": "database.py",
        "logic": """1. Imports: create_engine, sessionmaker, declarative_base from sqlalchemy.
2. Create engine using settings.DATABASE_URL.
3. Create SessionLocal class (autocommit=False, autoflush=False).
4. Create Base = declarative_base().
5. Define get_db() dependency that yields a session and closes it finally."""
      },
      {
        "path": "dependencies.py",
        "logic": """1. Imports: Depends, HTTPException, status. OAuth2PasswordBearer. JWTError, jwt. Session from sqlalchemy.
2. Import get_db from database, settings from config, models.
3. oauth2_scheme = OAuth2PasswordBearer(tokenUrl='auth/token').
4. get_current_user(token: str, db: Session):
   - Decode token using SECRET_KEY and ALGORITHM.
   - Extract email (sub).
   - Query DB for User. If not found, raise 401.
   - Return user.
5. get_admin_user(current_user: User):
   - Check if current_user.role in ['admin', 'instructor'].
   - If not, raise 403 (Not authorized)."""
      }
    ]
  },
  {
    "module_name": "Models",
    "description": "SQLAlchemy Database Models",
    "files": [
      {
        "path": "models/user.py",
        "logic": """1. Imports: Column, Integer, String, Boolean, ForeignKey, DateTime, Enum, JSON. Relationship from orm.
2. User Model:
   - id (UUID, PK), email (unique, index), hashed_password, role (enum: student, admin, instructor), created_at, updated_at.
   - Relationships: profile, subscription, progress, submissions.
3. UserProfile Model:
   - id (UUID, PK), user_id (FK User.id), first_name, last_name, avatar_url, current_level_tag (enum), xp (int), level (int), streak_count (int), last_login_date, badges (JSON).
4. Subscription Model:
   - id (UUID, PK), user_id (FK User.id), stripe_customer_id, stripe_subscription_id, status (enum), tier (enum), current_period_end."""
      },
      {
        "path": "models/course.py",
        "logic": """1. Imports: Column, Integer, String, Text, Boolean, ForeignKey, Enum. Relationship.
2. World Model:
   - id (UUID, PK), title, description, slug (unique), order_index, is_free, image_url, difficulty (enum), is_published.
   - Relationship: levels.
3. Level Model:
   - id (UUID, PK), world_id (FK World.id), title, order_index.
   - Relationship: lessons.
4. Lesson Model:
   - id (UUID, PK), level_id (FK Level.id), title, description, video_url, xp_value, order_index, is_boss_battle, duration_minutes.
   - Relationship: comments.
5. Comment Model:
   - id (UUID, PK), user_id (FK User.id), lesson_id (FK Lesson.id), parent_id (FK Comment.id, nullable), content, created_at."""
      },
      {
        "path": "models/progress.py",
        "logic": """1. Imports: Column, Integer, String, Boolean, ForeignKey, DateTime, Enum, Text.
2. UserProgress Model:
   - id (UUID, PK), user_id (FK User.id), lesson_id (FK Lesson.id), is_completed, completed_at.
   - UniqueConstraint(user_id, lesson_id).
3. BossSubmission Model:
   - id (UUID, PK), user_id (FK User.id), lesson_id (FK Lesson.id), video_url, status (enum: pending, approved, rejected), instructor_feedback, instructor_video_url, submitted_at, reviewed_at, reviewed_by (FK User.id)."""
      }
    ]
  },
  {
    "module_name": "Schemas",
    "description": "Pydantic Data Transfer Objects",
    "files": [
      {
        "path": "schemas/auth.py",
        "logic": """1. Imports: BaseModel, EmailStr.
2. UserRegisterRequest: email, password, first_name, last_name, current_level_tag.
3. UserLoginRequest: email, password.
4. TokenResponse: access_token, token_type.
5. TokenData: email (optional)."""
      },
      {
        "path": "schemas/course.py",
        "logic": """1. Imports: BaseModel, UUID, List, Optional, datetime.
2. CommentResponse: id, user_id, content, created_at, replies (List[CommentResponse]).
3. LessonResponse: id, title, description, video_url, xp_value, is_completed, is_locked, is_boss_battle.
4. LessonDetailResponse: Inherits LessonResponse + next_lesson_id, prev_lesson_id, comments.
5. WorldResponse: id, title, description, image_url, difficulty, progress_percentage, is_locked."""
      },
      {
        "path": "schemas/gamification.py",
        "logic": """1. Imports: BaseModel, UUID, List, Optional.
2. UserProfileResponse: id, first_name, last_name, xp, level, streak_count, tier, avatar_url.
3. XPGainResponse: xp_gained, new_total_xp, leveled_up (bool), new_level.
4. LeaderboardEntry: user_id, name, avatar_url, xp_total, rank."""
      }
    ]
  },
  {
    "module_name": "Routers",
    "description": "API Endpoints",
    "files": [
      {
        "path": "routers/auth.py",
        "logic": """1. Imports: APIRouter, Depends, HTTPException, status, Session. Schemas: auth. Models: user. Services: auth_service.
2. POST /register:
   - Check if email exists. If yes, 400.
   - Hash password.
   - Create User and UserProfile.
   - Commit.
   - Return TokenResponse (create_access_token).
3. POST /token:
   - Authenticate user (verify email/password).
   - If invalid, 401.
   - Return TokenResponse."""
      },
      {
        "path": "routers/users.py",
        "logic": """1. Imports: APIRouter, Depends. Schemas: gamification. Models: user. Dependencies: get_current_user.
2. GET /me:
   - Return current_user.profile converted to UserProfileResponse.
3. GET /leaderboard:
   - Query UserProfile, order by xp desc, limit 10.
   - Return List[LeaderboardEntry]."""
      },
      {
        "path": "routers/courses.py",
        "logic": """1. Imports: APIRouter, Depends, HTTPException. Schemas: course. Models: course, progress, user. Dependencies: get_current_user.
2. GET /worlds:
   - Fetch all Worlds.
   - For each world, calculate progress_percentage for current_user.
   - Check subscription status to determine is_locked (e.g., if world.is_free is False and sub is not active).
   - Return List[WorldResponse].
3. GET /lessons/{id}:
   - Fetch Lesson by ID.
   - Check prerequisites (is previous lesson completed?).
   - Return LessonDetailResponse."""
      },
      {
        "path": "routers/progress.py",
        "logic": """1. Imports: APIRouter, Depends. Schemas: gamification. Models: progress, user. Services: gamification_service.
2. POST /lessons/{id}/complete:
   - Check if UserProgress exists. If yes, return current stats.
   - Create UserProgress.
   - Add lesson.xp_value to user.profile.xp.
   - Call gamification_service.calculate_level to update level.
   - Call gamification_service.update_streak.
   - Commit.
   - Return XPGainResponse."""
      },
      {
        "path": "routers/submissions.py",
        "logic": """1. Imports: APIRouter, Depends. Models: progress. Services: s3_service.
2. POST /upload-url:
   - Input: filename, filetype.
   - Call s3_service.generate_presigned_url.
   - Return url.
3. POST /submit:
   - Input: lesson_id, video_url.
   - Create BossSubmission (status='pending').
   - Return SubmissionResponse."""
      },
      {
        "path": "routers/admin.py",
        "logic": """1. Imports: APIRouter, Depends. Models: all. Dependencies: get_admin_user.
2. GET /stats: Count users, active subs, pending submissions.
3. GET /submissions: List BossSubmission where status='pending'.
4. POST /submissions/{id}/grade:
   - Input: status, feedback.
   - Update BossSubmission.
   - If approved, ensure next content is unlocked (if applicable).
5. POST /worlds: Create/Update World/Level/Lesson structure."""
      },
      {
        "path": "routers/payments.py",
        "logic": """1. Imports: APIRouter, Request. Services: stripe_service.
2. POST /create-checkout-session: Call stripe_service.create_session.
3. POST /webhook: Verify signature, handle 'invoice.payment_succeeded', update Subscription model."""
      }
    ]
  },
  {
    "module_name": "Services",
    "description": "Business Logic and External Integrations",
    "files": [
      {
        "path": "services/auth_service.py",
        "logic": """1. Imports: passlib, jose (jwt), datetime.
2. pwd_context = CryptContext(schemes=['bcrypt']).
3. verify_password(plain, hashed).
4. get_password_hash(password).
5. create_access_token(data: dict, expires_delta)."""
      },
      {
        "path": "services/gamification_service.py",
        "logic": """1. calculate_level(xp): Return floor(xp / 1000) + 1.
2. update_streak(user_id, db): Check last_login_date. If yesterday, increment streak. If older, reset to 1. Update last_login_date to now."""
      },
      {
        "path": "services/s3_service.py",
        "logic": """1. Imports: boto3, botocore. Config: settings.
2. s3_client = boto3.client('s3', ...).
3. generate_presigned_url(object_name, expiration=3600): Generate PUT url for client uploads."""
      },
      {
        "path": "services/stripe_service.py",
        "logic": """1. Imports: stripe. Config: settings.
2. stripe.api_key = settings.STRIPE_SECRET_KEY.
3. create_checkout_session(user_id, price_id, success_url, cancel_url).
4. construct_event(payload, sig, secret)."""
      }
    ]
  }
]